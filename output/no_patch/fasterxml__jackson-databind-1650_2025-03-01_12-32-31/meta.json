{
    "task_id": "fasterxml__jackson-databind-1650",
    "setup_info": {
        "repo_path": "/Users/rabeyakhatunmuna/Documents/research/SOEN691-Project-AutoCodeRover/SWE-bench/testbed/fasterxml__jackson-databind/setup_fasterxml__jackson-databind__0.1",
        "env_name": "setup_fasterxml__jackson-databind__0.1",
        "pre_install": [],
        "install": "mvn clean install -Dmaven.test.skip=true",
        "test_cmd": "mvn clean test src/test/java/com/fasterxml/jackson/databind/type/RecursiveTypeTest.java src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactoryWithRecursiveTypes.java"
    },
    "task_info": {
        "repo": "fasterxml/jackson-databind",
        "pull_number": 1650,
        "instance_id": "fasterxml__jackson-databind-1650",
        "issue_numbers": [
            "1647"
        ],
        "base_commit": "e2476e07b2542d9791995d6a01b2da64e3c9128b",
        "patch": "diff --git a/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java b/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java\nindex 21f37fe1c7..12162c57fd 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java\n@@ -25,6 +25,14 @@ public void setReference(JavaType ref)\n         }\n         _referencedType = ref;\n     }\n+   \n+    @Override\n+    public JavaType getSuperClass() {\n+    \tif (_referencedType != null) {\n+    \t\treturn _referencedType.getSuperClass();\n+    \t}\n+    \treturn super.getSuperClass();\n+    }\n \n     public JavaType getSelfReferencedType() { return _referencedType; }\n \n",
        "test_patch": "diff --git a/src/test/java/com/fasterxml/jackson/databind/type/RecursiveTypeTest.java b/src/test/java/com/fasterxml/jackson/databind/type/RecursiveTypeTest.java\nindex 57115cf96b..f0643afdea 100644\n--- a/src/test/java/com/fasterxml/jackson/databind/type/RecursiveTypeTest.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/type/RecursiveTypeTest.java\n@@ -13,6 +13,15 @@ static class HashTree<K, V> extends HashMap<K, HashTree<K, V>> { }\n  // for [databind#938]\n     public static interface Ability<T> { }\n \n+    // for [databind#1647]\n+    static interface IFace<T> {}\n+\n+    // for [databind#1647]\n+    static class Base implements IFace<Sub> { }\n+\n+    // for [databind#1647]\n+    static class Sub extends Base { }\n+\n     public static final class ImmutablePair<L, R> implements Map.Entry<L, R>, Ability<ImmutablePair<L, R>> {\n         public final L key;\n         public final R value;\n@@ -93,4 +102,14 @@ public void testJavaTypeToString() throws Exception\n             fail(\"Description should contain 'recursive type', did not: \"+desc);\n         }\n     }\n+\n+    // for [databind#1647]\n+    public void testSuperClassWithReferencedJavaType() {\n+        TypeFactory tf = objectMapper().getTypeFactory();\n+        tf.constructType(Base.class); // must be constructed before sub to set the cache correctly\n+        JavaType subType = tf.constructType(Sub.class);\n+        // baseTypeFromSub should be a ResolvedRecursiveType in this test\n+        JavaType baseTypeFromSub = subType.getSuperClass();\n+        assertNotNull(baseTypeFromSub.getSuperClass());\n+    }\n }\ndiff --git a/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactoryWithRecursiveTypes.java b/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactoryWithRecursiveTypes.java\nnew file mode 100644\nindex 0000000000..50c5249389\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactoryWithRecursiveTypes.java\n@@ -0,0 +1,32 @@\n+package com.fasterxml.jackson.databind.type;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+\n+// https://github.com/FasterXML/jackson-databind/issues/1647\n+public class TestTypeFactoryWithRecursiveTypes extends BaseMapTest {\n+\n+    static interface IFace<T> {\n+    }\n+\n+    static class Base implements IFace<Sub> {\n+        @JsonProperty int base = 1;\n+    }\n+\n+    static class Sub extends Base {\n+        @JsonProperty int sub = 2;\n+    }\n+\n+    public void testBasePropertiesIncludedWhenSerializingSubWhenSubTypeLoadedAfterBaseType() throws IOException {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        tf.constructType(Base.class);\n+        tf.constructType(Sub.class);\n+        Sub sub = new Sub();\n+        String serialized = objectMapper().writeValueAsString(sub);\n+        assertEquals(\"{\\\"base\\\":1,\\\"sub\\\":2}\", serialized);\n+    }\n+}\n",
        "problem_statement": "Missing properties from base class when recursive types are involved.\nWhen a type hierarchy as follows is constructed and the base class' type is constructed first by the TypeFactory then serializing the sub class fails due to missing properties from the base class.\r\n\r\n```\r\nclass Base implements IFace<Sub> { @JsonProperty int base = 1 }\r\nclass Sub { @JsonProperty int sub = 2 }\r\ninterface IFace<T> {}\r\n```\r\n\r\nSerializes sub as `{\"sub\":2}` where `{\"base\":1,\"sub\":2}` is expected.\r\n\r\nI've created a minimal scenario of this bug here: https://github.com/slobo-showbie/jackson-recursive-type-bug\r\nI've experienced this bug in 2.7.8, 2.8.8, and 2.8.8.1\n",
        "hints_text": "The reason the `Base`'s fields are not serialized is that `AnnotatedClass#_findFields` does not return the fields from `Base`. Now, `_findFields` makes the assumption that if a class has no super class then it must be an Object or Interface (their fields are not to be returned). In order for `_findFields` to work the `JavaType` for `Sub` must be `SimpleType` and for `Base` also `SimpleType`. However in this case `Sub` is still a `SimpleType` but `Base` is a `ResolvedRecursiveType`; `ResolvedRecursiveType` does not return a super class, so `Base`'s fields are ignored by `_findFields`.\r\n\r\nThe reason `Base` is a `ResolvedRecursiveType` is because of `TypeFactory`'s cache. Consider:\r\n```\r\n1.   typeFactory.constructType(Base.class); // caches the type for Sub.class\r\n2.   typeFactory.constructType(Sub.class); // returns from the cache\r\n```\r\nOn line 1 constructType performs a recursive traversal like this:\r\n```\r\nBase(SimpleType) -> IFace<Sub>(?) -> Sub(SimpleType) -> Base(ResolvedRecursiveType)\r\n```\r\nThe second time `Base` is reached a `ResolvedRecursiveType` is generated rather than a `SimpleType`. However, also the intermediate types are cached, so the cached result returned by line 2 is\r\n```\r\nSub(SimpleType) with superclass = Base(ResolvedRecursiveType)\r\n```\r\nHowever if only line 2 is called without line 1, then the following would have been returned\r\n```\r\nSub(SimpleType) with superclass = Base(SimpleType)\r\n```\r\n",
        "created_at": 1496941822000,
        "FAIL_TO_PASS": [
            "src:com.fasterxml.jackson.databind.type.RecursiveTypeTest",
            "src:com.fasterxml.jackson.databind.type.TestTypeFactoryWithRecursiveTypes"
        ],
        "PASS_TO_PASS": [],
        "version": "0.1",
        "pr_link": "https://github.com/fasterxml/jackson-databind/pull/1650"
    }
}