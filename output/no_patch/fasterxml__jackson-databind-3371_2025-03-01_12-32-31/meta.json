{
    "task_id": "fasterxml__jackson-databind-3371",
    "setup_info": {
        "repo_path": "/Users/rabeyakhatunmuna/Documents/research/SOEN691-Project-AutoCodeRover/SWE-bench/testbed/fasterxml__jackson-databind/setup_fasterxml__jackson-databind__0.1",
        "env_name": "setup_fasterxml__jackson-databind__0.1",
        "pre_install": [],
        "install": "mvn clean install -Dmaven.test.skip=true",
        "test_cmd": "mvn clean test src/test/java/com/fasterxml/jackson/databind/deser/MergePolymorphicTest.java"
    },
    "task_info": {
        "repo": "fasterxml/jackson-databind",
        "pull_number": 3371,
        "instance_id": "fasterxml__jackson-databind-3371",
        "issue_numbers": [
            "2541"
        ],
        "base_commit": "abc6669d974f1f2d3074dbeba1b57b28f0bc065e",
        "patch": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java b/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\nindex ebfa4e07de..6a62f2effd 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n@@ -561,12 +561,16 @@ public final Object deserializeWith(JsonParser p, DeserializationContext ctxt,\n             }\n             return _nullProvider.getNullValue(ctxt);\n         }\n-        // 20-Oct-2016, tatu: Also tricky -- for now, report an error\n         if (_valueTypeDeserializer != null) {\n-            ctxt.reportBadDefinition(getType(),\n-                    String.format(\"Cannot merge polymorphic property '%s'\",\n-                            getName()));\n-//            return _valueDeserializer.deserializeWithType(p, ctxt, _valueTypeDeserializer);\n+            // 25-Oct-2021 Added by James to support merging polymorphic property\n+            // https://github.com/FasterXML/jackson-databind/issues/2541\n+            // Please note we only support merging same type polymorphic property for now,\n+            // merging different type is hard and usually doesn't make sense.\n+            // Please note you need to configure {@link DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES} as false to\n+            // enable this feature otherwise the unknown property exception will be thrown.\n+            JavaType subType = ctxt.getTypeFactory().constructType(toUpdate.getClass());\n+            JsonDeserializer<Object> subTypeValueDeserializer = ctxt.findContextualValueDeserializer(subType, this);\n+            return subTypeValueDeserializer.deserialize(p, ctxt, toUpdate);\n         }\n         // 04-May-2018, tatu: [databind#2023] Coercion from String (mostly) can give null\n         Object value = _valueDeserializer.deserialize(p, ctxt, toUpdate);\n",
        "test_patch": "diff --git a/src/test/java/com/fasterxml/jackson/databind/deser/MergePolymorphicTest.java b/src/test/java/com/fasterxml/jackson/databind/deser/MergePolymorphicTest.java\nnew file mode 100644\nindex 0000000000..7abbbaf88d\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/MergePolymorphicTest.java\n@@ -0,0 +1,82 @@\n+package com.fasterxml.jackson.databind.deser;\n+\n+import com.fasterxml.jackson.annotation.JsonMerge;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class MergePolymorphicTest extends BaseMapTest {\n+\n+    static class Root {\n+        @JsonMerge\n+        public Child child;\n+    }\n+\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME)\n+    @JsonSubTypes({\n+        @JsonSubTypes.Type(value = ChildA.class, name = \"ChildA\"),\n+        @JsonSubTypes.Type(value = ChildB.class, name = \"ChildB\")\n+    })\n+    static abstract class Child {\n+    }\n+\n+    static class ChildA extends Child {\n+        public String name;\n+    }\n+\n+    static class ChildB extends Child {\n+        public String code;\n+    }\n+\n+    public void testPolymorphicNewObject() throws JsonProcessingException {\n+        ObjectMapper mapper = new ObjectMapper().configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+        Root root = mapper.readValue(\"{\\\"child\\\": { \\\"@type\\\": \\\"ChildA\\\", \\\"name\\\": \\\"I'm child A\\\" }}\", Root.class);\n+        assertTrue(root.child instanceof ChildA);\n+        assertEquals(\"I'm child A\", ((ChildA) root.child).name);\n+    }\n+\n+    public void testPolymorphicFromNullToNewObject() throws JsonProcessingException {\n+        Root root = new Root();\n+        ObjectMapper mapper = new ObjectMapper().configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+        mapper.readerForUpdating(root).readValue(\"{\\\"child\\\": { \\\"@type\\\": \\\"ChildA\\\", \\\"name\\\": \\\"I'm the new name\\\" }}\");\n+        assertTrue(root.child instanceof ChildA);\n+        assertEquals(\"I'm the new name\", ((ChildA) root.child).name);\n+    }\n+\n+    public void testPolymorphicFromObjectToNull() throws JsonProcessingException {\n+        Root root = new Root();\n+        ChildA childA = new ChildA();\n+        childA.name = \"I'm child A\";\n+        root.child = childA;\n+        ObjectMapper mapper = new ObjectMapper().configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+        mapper.readerForUpdating(root).readValue(\"{\\\"child\\\": null }\");\n+        assertTrue(root.child == null);\n+    }\n+\n+    public void testPolymorphicPropertyCanBeMerged() throws JsonProcessingException {\n+        Root root = new Root();\n+        ChildA childA = new ChildA();\n+        childA.name = \"I'm child A\";\n+        root.child = childA;\n+        ObjectMapper mapper = new ObjectMapper().configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+        mapper.readerForUpdating(root).readValue(\"{\\\"child\\\": { \\\"@type\\\": \\\"ChildA\\\", \\\"name\\\": \\\"I'm the new name\\\" }}\");\n+        assertTrue(root.child instanceof ChildA);\n+        assertEquals(\"I'm the new name\", ((ChildA) root.child).name);\n+    }\n+\n+    public void testPolymorphicPropertyTypeCanNotBeChanged() throws JsonProcessingException {\n+        Root root = new Root();\n+        ChildA childA = new ChildA();\n+        childA.name = \"I'm child A\";\n+        root.child = childA;\n+        ObjectMapper mapper = new ObjectMapper().configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+        mapper.readerForUpdating(root).readValue(\"{\\\"child\\\": { \\\"@type\\\": \\\"ChildB\\\", \\\"code\\\": \\\"I'm the code\\\" }}\");\n+        // The polymorphic type can't be changed\n+        assertTrue(root.child instanceof ChildA);\n+        assertEquals(\"I'm child A\", ((ChildA) root.child).name);\n+    }\n+\n+}\n",
        "problem_statement": "Cannot merge polymorphic objects\nReferring to https://github.com/FasterXML/jackson-databind/issues/2336 because there was a similar issue with polymorphic maps that was addressed there, and at the end of that issue it mentions:\r\n\r\n> If attempts to provide some form of risky merging for polymorphic values are still desired, a new issue should be created (with reference to this issue for back story).\r\n\r\nWe are on version `2.10.0`\r\nI have some classes defined similarly to:\r\n```\r\npublic class MyRequest {\r\n  @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = As.PROPERTY, property = \"type\")\r\n  @JsonSubTypes({\r\n      @Type(value = ThingyAA.class, name = \"ThingyAA\"),\r\n      @Type(value = ThingyBB.class, name = \"ThingyBB\")\r\n  })\r\n  public BaseThingy<?> thingy;\r\n\r\n  @JacksonConstructor\r\n  public MyRequest() {\r\n  }\r\n\r\n  public MyRequest(BaseThingy<?> thingy) {\r\n    this.thingy = thingy;\r\n  }\r\n}\r\n\r\n@JsonIgnoreProperties(value = \"type\", allowGetters = true, allowSetters = false)\r\npublic abstract class BaseThingy<D extends BaseThingyConfig> {\r\n  public Map<Integer, D> config = new HashMap<>();\r\n  public String name;\r\n}\r\n\r\npublic abstract class BaseThingyConfig {\r\n  public final Map<String, Object> data = new HashMap<>();\r\n}\r\n\r\npublic class ThingyAAConfig extends BaseThingyConfig {\r\n  @InternalJSONColumn\r\n  public String foo;\r\n}\r\n\r\npublic class ThingyBBConfig extends BaseThingyConfig {\r\n  @InternalJSONColumn\r\n  public String bar;\r\n}\r\n\r\npublic class ThingyAA extends BaseThingy<ThingyAAConfig> {\r\n  @InternalJSONColumn\r\n  public String stuff;\r\n}\r\n\r\npublic class ThingyBB extends BaseThingy<ThingyBBConfig> {\r\n  @InternalJSONColumn\r\n  public String otherStuff;\r\n}\r\n```\r\n\r\nThe problem we're seeing is the incoming request completely overwrites the existing object instead of merging.\r\n\r\nIf we force a merge using `@JsonMerge` then an exception is thrown:\r\n```Cannot merge polymorphic property 'thingy'```\r\n\r\nThere are a few ways we're thinking of  trying to get around this. One is to create a custom deserializer. And another is to manually merge the json via a deep node merge before passing to the reader similar to:\r\n\r\n```\r\nObjectReader jsonNodeReader = objectMapper.readerFor(JsonNode.class);\r\nJsonNode existingNode = jsonNodeReader.readValue(objectMapper.writeValueAsBytes(currentValue));\r\nJsonNode incomingNode = jsonNodeReader.readValue(request.getInputStream());\r\nJsonNode merged = merge(existingNode, incomingNode);\r\nObjectReader patchReader = objectMapper.readerForUpdating(currentValue);\r\npatchReader.readValue(merged);\r\n\r\npublic static JsonNode merge(JsonNode mainNode, JsonNode updateNode) {\r\n    Iterator<String> fieldNames = updateNode.fieldNames();\r\n\r\n    while (fieldNames.hasNext()) {\r\n      String updatedFieldName = fieldNames.next();\r\n      JsonNode valueToBeUpdated = mainNode.get(updatedFieldName);\r\n      JsonNode updatedValue = updateNode.get(updatedFieldName);\r\n\r\n      // If the node is an @ArrayNode\r\n      if (valueToBeUpdated != null && valueToBeUpdated.isArray() &&\r\n          updatedValue.isArray()) {\r\n        // running a loop for all elements of the updated ArrayNode\r\n        for (int i = 0; i < updatedValue.size(); i++) {\r\n          JsonNode updatedChildNode = updatedValue.get(i);\r\n          // Create a new Node in the node that should be updated, if there was no corresponding node in it\r\n          // Use-case - where the updateNode will have a new element in its Array\r\n          if (valueToBeUpdated.size() <= i) {\r\n            ((ArrayNode) valueToBeUpdated).add(updatedChildNode);\r\n          }\r\n          // getting reference for the node to be updated\r\n          JsonNode childNodeToBeUpdated = valueToBeUpdated.get(i);\r\n          merge(childNodeToBeUpdated, updatedChildNode);\r\n        }\r\n        // if the Node is an @ObjectNode\r\n      } else if (valueToBeUpdated != null && valueToBeUpdated.isObject()) {\r\n        merge(valueToBeUpdated, updatedValue);\r\n      } else {\r\n        if (mainNode instanceof ObjectNode) {\r\n          ((ObjectNode) mainNode).replace(updatedFieldName, updatedValue);\r\n        }\r\n      }\r\n    }\r\n    return mainNode;\r\n  }\r\n```\r\n\r\nCan some type of deep node merge occur in Jackson for this polymorphic scenario to alleviate us having to maintain this json functionality ourselves?\n",
        "hints_text": "The workaround we ended up going with was writing a custom Deserializer that extends `StdDeserializer` reads the request into a `JsonNode`, get the Thingy from the request, and then use a `readForUpdating` reader to deserialize that normally and put the deserialized object back on the request.\r\nLike so:\r\n```\r\npublic class ThingyDeserializer extends StdDeserializer<MyRequest> {\r\n  public ThingyDeserializer() {\r\n    super(MyRequest.class);\r\n  }\r\n\r\n  @Override\r\n  public MyRequest deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\r\n    return p.readValueAs(MyRequest.class);\r\n  }\r\n\r\n  @Override\r\n  public MyRequest deserialize(JsonParser p, DeserializationContext ctxt, MyRequest req) throws IOException {\r\n    JsonNode incomingNode = p.getCodec().readTree(p);\r\n    JsonNode thingyNode = incomingNode.get(\"thingy\");\r\n    BaseThingy thingy = req.thingy;\r\n    if (idp == null) {\r\n      idp = getThingy(thingyNode);\r\n    }\r\n\r\n    if (idp != null) {\r\n      ObjectReader reader = ((ObjectMapper) p.getCodec()).readerForUpdating(thingy);\r\n      reader.readValue(thingyNode);\r\n    }\r\n\r\n    req.thingy = thingy;\r\n    return req;\r\n  }\r\n\r\n  private BaseThingy getThingy(JsonNode thingyNode) {\r\n    if (thingyNode == null) {\r\n      return null;\r\n    }\r\n\r\n    String type = thingyNode.get(\"type\").asText();\r\n\r\n    switch (type) {\r\n      case \"ThingyAA\":\r\n        return new ThingyAA();\r\n      case \"ThingyBB\":\r\n        return new ThingyBB();\r\n    }\r\n  }\r\n}\r\n```\nDo we have any plan to support merging polymorphic objects?  From my point of view, a polymorphic object which needs to be merged should not change its type,  if this is the precondition then the merge process should be easy, just read the original object and set its fields.\r\n\r\nWe have lots of polymorphic models in our project and heavily depend on this feature,  it would be nice to support this in the new version.\nYes, it often appears things are easy when you are not familiar with the details. This may be one of these cases.\r\nA fundamental problem is that the polymorphic type information must be present in case of data merging and figuring out how to handle difference between metadata (type info) and data (properties) is non trivial.\r\nThis is partly since merging is just a slightly special case of regular deserialization, and not separate of its own (if it was things would be easier here although would also require a lot of duplicated code).\r\n\r\nI'd be happy to help anyone who can implement it, but at this point do not have time to try to tackle the problem myself.\r\n\nThanks for providing the detail information,  I'll try if I can track the problem and send a pull request later.\nGood luck!\nHi Tatu,\r\n\r\nI have added the merging polymorphic property logic in the code and tested, it works as expected now,  the limitation is we can only merge the same sub type property,  and I think it should be the case for most scenarios,  changing the type of a polymorphic object doesn't make sense and it's not accepted by JPA as well,  below is my implementation, please advice if there are any problems:\r\n\r\n\r\n      SettableBeanProperty.deserializeWith(JsonParser p, DeserializationContext ctxt,\r\n                                        Object toUpdate)\r\n```\r\n        // 20-Oct-2016, tatu: Also tricky -- for now, report an error\r\n        if (_valueTypeDeserializer != null) {\r\n            // 25-Oct-2021 Added by James to support merging polymorphic property\r\n            // https://github.com/FasterXML/jackson-databind/issues/2541\r\n            // Please note we only support merging same type polymorphic property for now,\r\n            // merging different type is hard and usually doesn't make sense\r\n            JavaType subType = ctxt.getTypeFactory().constructType(toUpdate.getClass());\r\n            JsonDeserializer<Object> subTypeValueDeserializer = ctxt.findContextualValueDeserializer(subType, this);\r\n            return subTypeValueDeserializer.deserialize(p, ctxt, toUpdate);\r\n        }\r\n```\nAny suggestions on the modification? Can I send a pull request for this?\nWould this actually work, for all kinds of polymorphic type embedding? Since this ignores `_valueTypeDeserializer` (which handles type id use/transformations), wouldn't it fail for many cases?\r\n\r\nYou can definitely submit a PR, with tests to show expected working usage. I hope to have to look into it, although right now have bit of a time crunch.\r\nBut maybe we can find others to have a look at proposed changes as well; as well as find likely edge cases.\r\n\nIt only supports merging the same type polymorphic property, say if we have an old value which type is A,  we can't change it to B in the merging process, like you said, changing the polymorphic type is very hard, and it usually doesn't make sense.\r\n\r\nI'll try to add unit tests to show the usage and submit a PR later, do you know who else can look at this?\nMy concern is beyond different types -- yes, type cannot change, but more important, Type Id information should be incoming (json) content so who should handle that and how?\r\n\r\nIf you submit PR, I can have a look & you can ask others on the mailing list. There are a few active collaborators but they mostly work on specific modules.\r\n",
        "created_at": 1642197213000,
        "FAIL_TO_PASS": [
            "src:com.fasterxml.jackson.databind.deser.MergePolymorphicTest"
        ],
        "PASS_TO_PASS": [],
        "version": "0.1",
        "pr_link": "https://github.com/fasterxml/jackson-databind/pull/3371"
    }
}