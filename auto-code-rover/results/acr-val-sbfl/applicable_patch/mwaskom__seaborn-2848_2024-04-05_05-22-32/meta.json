{
    "task_id": "mwaskom__seaborn-2848",
    "setup_info": {
        "repo_path": "/media/media0/yuntong/SWE-bench/testbed/mwaskom__seaborn/setup_mwaskom__seaborn__0.12",
        "env_name": "setup_mwaskom__seaborn__0.12",
        "pre_install": [],
        "install": "python -m pip install -e .[dev]",
        "test_cmd": "pytest --no-header -rA tests/test_relational.py"
    },
    "task_info": {
        "instance_id": "mwaskom__seaborn-2848",
        "base_commit": "94621cef29f80282436d73e8d2c0aa76dab81273",
        "hints_text": "The following workarounds seem to work:\r\n```\r\ng.map(sns.scatterplot, hue=iris[\"species\"], hue_order=iris[\"species\"].unique())\r\n```\r\nor\r\n```\r\ng.map(lambda x, y, **kwargs: sns.scatterplot(x=x, y=y, hue=iris[\"species\"]))\r\n```\n> ```\r\n> g.map(sns.scatterplot, hue=iris[\"species\"], hue_order=iris[\"species\"].unique())\r\n> ```\r\n\r\nThe workaround fixes the problem for me.\r\nThank you very much!\r\n\r\n@mwaskom Should I close the Issue or leave it open until the bug is fixed?\nThat's a good workaround, but it's still a bug. The problem is that `PairGrid` now lets `hue` at the grid-level delegate to the axes-level functions if they have `hue` in their signature. But it's not properly handling the case where `hue` is *not* set for the grid, but *is* specified for one mapped function. @jhncls's workaround suggests the fix.\r\n\r\nAn easier workaround would have been to set `PairGrid(..., hue=\"species\")` and then pass `.map(..., hue=None)` where you don't want to separate by species. But `regplot` is the one axis-level function that does not yet handle hue-mapping internally, so it doesn't work for this specific case. It would have if you wanted a single bivariate density over hue-mapped scatterplot points (i.e. [this example](http://seaborn.pydata.org/introduction.html#classes-and-functions-for-making-complex-graphics) or something similar.",
        "created_at": "2022-06-11T18:21:32Z",
        "test_patch": "diff --git a/tests/test_relational.py b/tests/test_relational.py\n--- a/tests/test_relational.py\n+++ b/tests/test_relational.py\n@@ -9,6 +9,7 @@\n \n from seaborn.external.version import Version\n from seaborn.palettes import color_palette\n+from seaborn._oldcore import categorical_order\n \n from seaborn.relational import (\n     _RelationalPlotter,\n@@ -1623,6 +1624,16 @@ def test_supplied_color_array(self, long_df):\n         _draw_figure(ax.figure)\n         assert_array_equal(ax.collections[0].get_facecolors(), colors)\n \n+    def test_hue_order(self, long_df):\n+\n+        order = categorical_order(long_df[\"a\"])\n+        unused = order.pop()\n+\n+        ax = scatterplot(data=long_df, x=\"x\", y=\"y\", hue=\"a\", hue_order=order)\n+        points = ax.collections[0]\n+        assert (points.get_facecolors()[long_df[\"a\"] == unused] == 0).all()\n+        assert [t.get_text() for t in ax.legend_.texts] == order\n+\n     def test_linewidths(self, long_df):\n \n         f, ax = plt.subplots()\n",
        "repo": "mwaskom/seaborn",
        "problem_statement": "PairGrid errors with `hue` assigned in `map`\nIn seaborn version 0.9.0 I was able to use the following Code to plot scatterplots across a PairGrid with categorical hue. The reason I am not using the \"hue\" keyword in creating the PairGrid is, that I want one regression line (with regplot) and not one regression per hue-category.\r\n```python\r\nimport seaborn as sns\r\niris = sns.load_dataset(\"iris\")\r\ng = sns.PairGrid(iris, y_vars=[\"sepal_length\",\"sepal_width\"], x_vars=[\"petal_length\",\"petal_width\"])\r\ng.map(sns.scatterplot, hue=iris[\"species\"])\r\ng.map(sns.regplot, scatter=False)\r\n```\r\n\r\nHowever, since I updated to searbon 0.11.1 the following Error message occurs:\r\n```\r\n---------------------------------------------------------------------------\r\nKeyError                                  Traceback (most recent call last)\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/_core.py in _lookup_single(self, key)\r\n    143             # Use a value that's in the original data vector\r\n--> 144             value = self.lookup_table[key]\r\n    145         except KeyError:\r\n\r\nKeyError: 'setosa'\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTypeError                                 Traceback (most recent call last)\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/_core.py in _lookup_single(self, key)\r\n    148             try:\r\n--> 149                 normed = self.norm(key)\r\n    150             except TypeError as err:\r\n\r\nTypeError: 'NoneType' object is not callable\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTypeError                                 Traceback (most recent call last)\r\n<ipython-input-3-46dd21e9c95a> in <module>\r\n      2 iris = sns.load_dataset(\"iris\")\r\n      3 g = sns.PairGrid(iris, y_vars=[\"sepal_length\",\"sepal_width\"], x_vars=[\"petal_length\",\"species\"])\r\n----> 4 g.map(sns.scatterplot, hue=iris[\"species\"])\r\n      5 \r\n\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/axisgrid.py in map(self, func, **kwargs)\r\n   1263         row_indices, col_indices = np.indices(self.axes.shape)\r\n   1264         indices = zip(row_indices.flat, col_indices.flat)\r\n-> 1265         self._map_bivariate(func, indices, **kwargs)\r\n   1266 \r\n   1267         return self\r\n\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/axisgrid.py in _map_bivariate(self, func, indices, **kwargs)\r\n   1463             if ax is None:  # i.e. we are in corner mode\r\n   1464                 continue\r\n-> 1465             self._plot_bivariate(x_var, y_var, ax, func, **kws)\r\n   1466         self._add_axis_labels()\r\n   1467 \r\n\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/axisgrid.py in _plot_bivariate(self, x_var, y_var, ax, func, **kwargs)\r\n   1503         kwargs.setdefault(\"hue_order\", self._hue_order)\r\n   1504         kwargs.setdefault(\"palette\", self._orig_palette)\r\n-> 1505         func(x=x, y=y, **kwargs)\r\n   1506 \r\n   1507         self._update_legend_data(ax)\r\n\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/_decorators.py in inner_f(*args, **kwargs)\r\n     44             )\r\n     45         kwargs.update({k: arg for k, arg in zip(sig.parameters, args)})\r\n---> 46         return f(**kwargs)\r\n     47     return inner_f\r\n     48 \r\n\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/relational.py in scatterplot(x, y, hue, style, size, data, palette, hue_order, hue_norm, sizes, size_order, size_norm, markers, style_order, x_bins, y_bins, units, estimator, ci, n_boot, alpha, x_jitter, y_jitter, legend, ax, **kwargs)\r\n    818     p._attach(ax)\r\n    819 \r\n--> 820     p.plot(ax, kwargs)\r\n    821 \r\n    822     return ax\r\n\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/relational.py in plot(self, ax, kws)\r\n    626         # Apply the mapping from semantic variables to artist attributes\r\n    627         if \"hue\" in self.variables:\r\n--> 628             c = self._hue_map(data[\"hue\"])\r\n    629 \r\n    630         if \"size\" in self.variables:\r\n\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/_core.py in __call__(self, key, *args, **kwargs)\r\n     61         \"\"\"Get the attribute(s) values for the data key.\"\"\"\r\n     62         if isinstance(key, (list, np.ndarray, pd.Series)):\r\n---> 63             return [self._lookup_single(k, *args, **kwargs) for k in key]\r\n     64         else:\r\n     65             return self._lookup_single(key, *args, **kwargs)\r\n\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/_core.py in <listcomp>(.0)\r\n     61         \"\"\"Get the attribute(s) values for the data key.\"\"\"\r\n     62         if isinstance(key, (list, np.ndarray, pd.Series)):\r\n---> 63             return [self._lookup_single(k, *args, **kwargs) for k in key]\r\n     64         else:\r\n     65             return self._lookup_single(key, *args, **kwargs)\r\n\r\n~/.Software/miniforge3/envs/py3.9/lib/python3.8/site-packages/seaborn/_core.py in _lookup_single(self, key)\r\n    149                 normed = self.norm(key)\r\n    150             except TypeError as err:\r\n--> 151                 if np.isnan(key):\r\n    152                     value = (0, 0, 0, 0)\r\n    153                 else:\r\n\r\nTypeError: ufunc 'isnan' not supported for the input types, and the inputs could not be safely coerced to any supported types according to the casting rule ''safe''\r\n```\r\n\r\nMy further observations are:\r\n- the error does not occur when using the \"hue\" keyword when creating PairGrid\r\n- the error does not occur for numerical values for hue\r\n- changing the dtype to \"categorical\" does not help\r\n\r\nEdit:\r\nI tried all versions between 0.9.0 and the current release (0.11.1) and the error only occurs in the current release. If I use 0.11.0, the plot seems to work.\n",
        "version": "0.12",
        "FAIL_TO_PASS": [
            "tests/test_relational.py::TestScatterPlotter::test_hue_order"
        ],
        "PASS_TO_PASS": [
            "tests/test_relational.py::TestLinePlotter::test_axis_labels",
            "tests/test_relational.py::TestLinePlotter::test_legend_data",
            "tests/test_relational.py::TestLinePlotter::test_plot",
            "tests/test_relational.py::TestRelationalPlotter::test_ax_kwarg_removal",
            "tests/test_relational.py::TestRelationalPlotter::test_facet_variable_collision",
            "tests/test_relational.py::TestRelationalPlotter::test_flat_array_variables",
            "tests/test_relational.py::TestRelationalPlotter::test_flat_list_variables",
            "tests/test_relational.py::TestRelationalPlotter::test_flat_series_variables",
            "tests/test_relational.py::TestRelationalPlotter::test_relplot_complex",
            "tests/test_relational.py::TestRelationalPlotter::test_relplot_data",
            "tests/test_relational.py::TestRelationalPlotter::test_relplot_hues",
            "tests/test_relational.py::TestRelationalPlotter::test_relplot_sizes",
            "tests/test_relational.py::TestRelationalPlotter::test_relplot_stringy_numerics",
            "tests/test_relational.py::TestRelationalPlotter::test_relplot_styles",
            "tests/test_relational.py::TestRelationalPlotter::test_relplot_vectors[list]",
            "tests/test_relational.py::TestRelationalPlotter::test_relplot_vectors[numpy]",
            "tests/test_relational.py::TestRelationalPlotter::test_relplot_vectors[series]",
            "tests/test_relational.py::TestRelationalPlotter::test_relplot_wide",
            "tests/test_relational.py::TestRelationalPlotter::test_wide_array_variables",
            "tests/test_relational.py::TestRelationalPlotter::test_wide_df_variables",
            "tests/test_relational.py::TestRelationalPlotter::test_wide_df_with_nonnumeric_variables",
            "tests/test_relational.py::TestRelationalPlotter::test_wide_dict_of_arrays_variables",
            "tests/test_relational.py::TestRelationalPlotter::test_wide_dict_of_lists_variables",
            "tests/test_relational.py::TestRelationalPlotter::test_wide_dict_of_series_variables",
            "tests/test_relational.py::TestRelationalPlotter::test_wide_list_of_arrays_variables",
            "tests/test_relational.py::TestRelationalPlotter::test_wide_list_of_list_variables",
            "tests/test_relational.py::TestRelationalPlotter::test_wide_list_of_series_variables",
            "tests/test_relational.py::TestScatterPlotter::test_axis_labels",
            "tests/test_relational.py::TestScatterPlotter::test_color",
            "tests/test_relational.py::TestScatterPlotter::test_datetime_scale",
            "tests/test_relational.py::TestScatterPlotter::test_legend_data",
            "tests/test_relational.py::TestScatterPlotter::test_linewidths",
            "tests/test_relational.py::TestScatterPlotter::test_literal_attribute_vectors",
            "tests/test_relational.py::TestScatterPlotter::test_plot",
            "tests/test_relational.py::TestScatterPlotter::test_scatterplot_axes",
            "tests/test_relational.py::TestScatterPlotter::test_scatterplot_smoke",
            "tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics0]",
            "tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics10]",
            "tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics11]",
            "tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics1]",
            "tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics2]",
            "tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics3]",
            "tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics4]",
            "tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics5]",
            "tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics6]",
            "tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics7]",
            "tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics8]",
            "tests/test_relational.py::TestScatterPlotter::test_scatterplot_vs_relplot[long_semantics9]",
            "tests/test_relational.py::TestScatterPlotter::test_size_norm_extrapolation",
            "tests/test_relational.py::TestScatterPlotter::test_supplied_color_array"
        ],
        "environment_setup_commit": "d25872b0fc99dbf7e666a91f59bd4ed125186aa1",
        "patch": "diff --git a/seaborn/_oldcore.py b/seaborn/_oldcore.py\n--- a/seaborn/_oldcore.py\n+++ b/seaborn/_oldcore.py\n@@ -149,6 +149,13 @@ def _lookup_single(self, key):\n             # Use a value that's in the original data vector\n             value = self.lookup_table[key]\n         except KeyError:\n+\n+            if self.norm is None:\n+                # Currently we only get here in scatterplot with hue_order,\n+                # because scatterplot does not consider hue a grouping variable\n+                # So unused hue levels are in the data, but not the lookup table\n+                return (0, 0, 0, 0)\n+\n             # Use the colormap to interpolate between existing datapoints\n             # (e.g. in the context of making a continuous legend)\n             try:\n",
        "pr_link": "https://github.com/mwaskom/seaborn/pull/2848"
    }
}